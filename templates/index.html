<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Content Analyzer with TTS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        
        .container {
            flex: 1;
            max-width: 900px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            position: relative;
            z-index: 1;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 14px;
        }
        
        .mode-selector {
            background: white;
            padding: 20px 30px;
            border-bottom: 2px solid #f0f0f0;
        }
        
        .mode-selector h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 16px;
        }
        
        .mode-options {
            display: flex;
            gap: 15px;
        }
        
        .mode-option {
            flex: 1;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .mode-option:hover {
            border-color: #667eea;
            background: #f8f9ff;
        }
        
        .mode-option.active {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
        }
        
        .mode-option input[type="radio"] {
            display: none;
        }
        
        .mode-option label {
            cursor: pointer;
            font-weight: 600;
            color: #333;
            display: block;
        }
        
        .mode-option p {
            margin-top: 5px;
            font-size: 12px;
            color: #666;
        }
        
        .content {
            padding: 30px;
        }
        
        .url-section {
            margin-bottom: 30px;
        }
        
        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        input[type="text"] {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background: #667eea;
            color: white;
        }
        
        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }
        
        .btn-secondary:hover {
            background: #e0e0e0;
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .chat-container {
            background: #f9f9f9;
            border-radius: 8px;
            padding: 20px;
            max-height: 500px;
            overflow-y: auto;
            margin-bottom: 20px;
        }
        
        .message {
            margin-bottom: 20px;
            animation: fadeIn 0.3s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .message-user {
            text-align: right;
        }
        
        .message-content {
            display: inline-block;
            padding: 12px 16px;
            border-radius: 12px;
            max-width: 80%;
            word-wrap: break-word;
        }
        
        .message-user .message-content {
            background: #667eea;
            color: white;
        }
        
        .message-assistant .message-content {
            background: white;
            color: #333;
            border: 1px solid #e0e0e0;
        }
        
        .message-label {
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }
        
        .chat-input-container {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .chat-input-container input {
            flex: 1;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .checkbox-group label {
            cursor: pointer;
            user-select: none;
        }
        
        .status {
            padding: 10px 16px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 14px;
        }
        
        .status-info {
            background: #e3f2fd;
            color: #1976d2;
        }
        
        .status-error {
            background: #ffebee;
            color: #c62828;
        }
        
        .status-success {
            background: #e8f5e9;
            color: #2e7d32;
        }
        
        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 3px solid rgba(102, 126, 234, 0.3);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .button-group {
            display: flex;
            gap: 10px;
        }
        
        .queue-panel {
            width: 320px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 20px;
            height: fit-content;
            z-index: 1;
            position: sticky;
            top: 20px;
        }

        .queue-panel h3 {
            color: #667eea;
            font-size: 16px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .queue-section {
            margin-bottom: 20px;
        }

        .queue-section textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            min-height: 120px;
            transition: border-color 0.3s;
        }

        .queue-section textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .queue-section textarea:read-only {
            background-color: #f9f9f9;
            cursor: not-allowed;
        }

        .queue-section .label {
            font-size: 13px;
            font-weight: 600;
            color: #333;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-processing {
            background-color: #ff9800;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .email-panel {
            width: 320px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 20px;
            height: fit-content;
            position: sticky;
            z-index: 1;
            top: 20px;
        }
        
        .email-panel h3 {
            color: #667eea;
            font-size: 18px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .email-form {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .email-form textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 13px;
            font-family: inherit;
            resize: vertical;
            min-height: 100px;
            transition: border-color 0.3s;
        }
        
        .email-form textarea:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }
        
        .file-input-label {
            display: block;
            padding: 10px;
            background: #f0f0f0;
            border: 2px dashed #d0d0d0;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            font-size: 13px;
            color: #666;
            transition: all 0.3s;
        }
        
        .file-input-label:hover {
            background: #e8f4f8;
            border-color: #667eea;
            color: #667eea;
        }
        
        .file-list {
            font-size: 12px;
            color: #666;
            max-height: 80px;
            overflow-y: auto;
        }
        
        .file-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 8px;
            background: #f9f9f9;
            border-radius: 4px;
            margin-bottom: 4px;
        }
        
        .file-item-name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .file-remove {
            color: #f44336;
            cursor: pointer;
            font-size: 16px;
            padding: 0 4px;
        }
        
        .file-remove:hover {
            color: #d32f2f;
        }
    </style>
</head>
<body>
    <!-- Queue Panel (Left Side) -->
    <div class="queue-panel">
        <h3>‚ö° Auto Processor</h3>
        
        <div class="queue-section">
            <div class="label">
                üìã Queue (Editable)
            </div>
            <textarea 
                id="queueList" 
                placeholder="Paste URLs here (one per line)&#10;e.g.,&#10;https://youtube.com/watch?v=...&#10;https://example.com/article"
            ></textarea>
        </div>
        
        <div class="queue-section">
            <div class="label">
                <span id="processingIndicator"></span>
                ‚öôÔ∏è Processing
            </div>
            <textarea 
                id="processingList" 
                readonly
                placeholder="Currently processing URL will appear here"
            ></textarea>
        </div>
        
        <div class="queue-section">
            <div class="label">
                ‚ùå Failed
            </div>
            <textarea 
                id="failedList" 
                readonly
                placeholder="Failed URLs will appear here"
            ></textarea>
        </div>
        
        <div class="queue-section">
            <div class="label">
                ‚úÖ Finished
            </div>
            <textarea 
                id="finishedList" 
                readonly
                placeholder="Successfully processed URLs will appear here"
            ></textarea>
        </div>
    </div>

    <div class="container">
        <!-- <div class="header">
            <h1>üì∞ Content Analyzer with TTS</h1>
            <p>Analyze news articles or YouTube videos with AI</p>
        </div> -->
        
        <!-- Mode Selector -->
        <div class="mode-selector">
            <h3>Select Mode:</h3>
            <div class="mode-options">
                <div class="mode-option" onclick="selectMode('news')">
                    <input type="radio" id="modeNews" name="mode" value="news">
                    <label for="modeNews">üì∞ News Article</label>
                    <p>Analyze and discuss news articles</p>
                </div>
                <div class="mode-option active" onclick="selectMode('youtube')">
                    <input type="radio" id="modeYoutube" name="mode" value="youtube" checked>
                    <label for="modeYoutube">üé• YouTube Transcript</label>
                    <p>Condense video transcripts</p>
                </div>
            </div>
        </div>
        
        <div class="content">
            <!-- URL Input Section -->
            <div class="url-section">
                <div class="input-group">
                    <input 
                        type="text" 
                        id="urlInput" 
                        placeholder="Enter news article URL (e.g., https://example.com/article)"
                    >
                    <button class="btn btn-primary" id="loadBtn" onclick="loadContent()">
                        Load Content
                    </button>
                </div>
            </div>
            
            <!-- Status Messages -->
            <div id="statusMessage"></div>
            
            <!-- Chat Container -->
            <div class="chat-container" id="chatContainer"></div>
            
            <!-- Chat Input Section -->
            <div class="chat-input-container">
                <input 
                    type="text" 
                    id="chatInput" 
                    placeholder="Ask a question about the content..."
                    disabled
                    onkeypress="handleKeyPress(event)"
                >
                <button class="btn btn-primary" id="sendBtn" onclick="sendMessage()" disabled>
                    Send
                </button>
            </div>
            
            <div class="checkbox-group">
                <input type="checkbox" id="audioCheckbox" checked>
                <label for="audioCheckbox">Generate audio (TTS)</label>
            </div>
            
            <div class="button-group">
                <button class="btn btn-secondary" onclick="clearConversation()">
                    Clear Conversation
                </button>
            </div>
        </div>
    </div>
    
    <!-- Email Sender Panel -->
    <div class="email-panel">
        <h3>üìß Quick Email</h3>
        <div class="email-form">
            <textarea 
                id="emailText" 
                placeholder="Type your message here..."
            ></textarea>
            
            <div class="file-input-wrapper">
                <input 
                    type="file" 
                    id="emailAttachment" 
                    multiple
                    accept=".wav,.mp3,.pdf,.txt,.doc,.docx"
                    onchange="handleFileSelect(event)"
                >
                <label for="emailAttachment" class="file-input-label">
                    üìé Attach Files
                </label>
            </div>
            
            <div id="fileList" class="file-list"></div>
            
            <div style="display: flex; gap: 8px;">
                <button 
                    class="btn btn-primary" 
                    onclick="sendQuickEmail()" 
                    id="quickEmailBtn"
                    style="flex: 1; background: #4caf50;"
                >
                    üìß Email
                </button>
                <button 
                    class="btn btn-primary" 
                    onclick="sendQuickTelegram()" 
                    id="quickTelegramBtn"
                    style="flex: 1; background: #0088cc;"
                >
                    ‚úàÔ∏è Telegram
                </button>
            </div>
        </div>
    </div>
    
    <!-- Text to Audio Tool -->
    <div class="email-panel">
        <h3>üéôÔ∏è Text to Audio</h3>
        <div class="email-form">
            <textarea 
                id="audioText" 
                placeholder="Paste or type text to convert to audio..."
                style="min-height: 150px;"
            ></textarea>
            
            <div id="audioStatus" style="margin: 10px 0; padding: 10px; border-radius: 6px; display: none;"></div>
            
            <div id="audioPlayer" style="margin: 10px 0; display: none;">
                <audio controls style="width: 100%; border-radius: 6px;">
                    <source id="audioSource" type="audio/wav">
                </audio>
            </div>
            
            <button 
                class="btn btn-primary" 
                onclick="generateAudio()" 
                id="generateAudioBtn"
                style="width: 100%; background: #9c27b0;"
            >
                üéôÔ∏è Generate Audio
            </button>
        </div>
    </div>
    
    <script>
        let selectedFiles = [];
        let isLoading = false;
        let currentMode = 'youtube';
        let currentUrl = '';
        
        // Auto-processor state
        let isProcessing = false;
        let autoProcessorEnabled = true;
        
        // Initialize auto-processor on page load
        document.addEventListener('DOMContentLoaded', function() {
            loadQueuesFromStorage();
            startAutoProcessor();
            
            // Save queue when user edits it
            document.getElementById('queueList').addEventListener('input', saveQueuesToStorage);
            
            // Handle page visibility changes to resume processing if tab becomes visible
            document.addEventListener('visibilitychange', function() {
                if (!document.hidden && autoProcessorEnabled && !isProcessing) {
                    console.log('[AUTO-PROCESSOR] Tab became visible, checking queue...');
                    processNextLink();
                }
            });
        });
        
        // Load queues from localStorage
        function loadQueuesFromStorage() {
            const queueList = localStorage.getItem('queueList') || '';
            const processingList = localStorage.getItem('processingList') || '';
            const failedList = localStorage.getItem('failedList') || '';
            const finishedList = localStorage.getItem('finishedList') || '';
            
            document.getElementById('queueList').value = queueList;
            document.getElementById('processingList').value = processingList;
            document.getElementById('failedList').value = failedList;
            document.getElementById('finishedList').value = finishedList;
        }
        
        // Save queues to localStorage
        function saveQueuesToStorage() {
            localStorage.setItem('queueList', document.getElementById('queueList').value);
            localStorage.setItem('processingList', document.getElementById('processingList').value);
            localStorage.setItem('failedList', document.getElementById('failedList').value);
            localStorage.setItem('finishedList', document.getElementById('finishedList').value);
        }
        
        // Start the auto-processor
        function startAutoProcessor() {
            console.log('[AUTO-PROCESSOR] Starting...');
            autoProcessorEnabled = true;
            processNextLink(); // Start processing immediately
        }
        
        // Process the next link in the queue
        async function processNextLink() {
            if (!autoProcessorEnabled) {
                console.log('[AUTO-PROCESSOR] Disabled, stopping...');
                return;
            }
            
            if (isProcessing) {
                console.log('[AUTO-PROCESSOR] Already processing, will retry...');
                // Retry after 2 seconds
                setTimeout(processNextLink, 2000);
                return;
            }
            
            const processingListEl = document.getElementById('processingList');
            const queueListEl = document.getElementById('queueList');
            
            // Check if processing list is empty
            if (processingListEl.value.trim()) {
                console.log('[AUTO-PROCESSOR] Processing list not empty, waiting...');
                // Retry after 2 seconds
                setTimeout(processNextLink, 2000);
                return;
            }
            
            // Get URLs from queue
            const urls = queueListEl.value.split('\n').filter(line => line.trim());
            
            if (urls.length === 0) {
                // Queue is empty, hide processing indicator and wait
                document.getElementById('processingIndicator').innerHTML = '';
                console.log('[AUTO-PROCESSOR] Queue empty, waiting for new items...');
                // Check again in 5 seconds in case user adds more
                setTimeout(processNextLink, 5000);
                return;
            }
            
            // Get the first URL from queue
            const url = urls[0].trim();
            console.log(`[AUTO-PROCESSOR] Moving to processing: ${url}`);
            
            // Move URL from queue to processing
            urls.shift(); // Remove first URL from queue
            queueListEl.value = urls.join('\n');
            processingListEl.value = url;
            saveQueuesToStorage();
            
            // Show processing indicator
            document.getElementById('processingIndicator').innerHTML = '<span class="status-indicator status-processing"></span>';
            isProcessing = true;
            
            // Detect mode from URL
            const mode = url.includes('youtube.com') || url.includes('youtu.be') ? 'youtube' : 'news';
            
            try {
                const response = await fetch('/load_content', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ url, mode, auto_send_telegram: true })
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    // Success - move to finished list
                    console.log(`[AUTO-PROCESSOR] ‚úÖ Success: ${url}`);
                    moveToFinished(url);
                } else {
                    // Failed - move to failed list
                    const errorMsg = data.error || 'Unknown error';
                    console.log(`[AUTO-PROCESSOR] ‚ùå Failed: ${url} - ${errorMsg}`);
                    moveToFailed(url, errorMsg);
                }
            } catch (error) {
                // Network or other error - move to failed list
                console.log(`[AUTO-PROCESSOR] ‚ùå Error: ${url} - ${error.message}`);
                moveToFailed(url, error.message);
            } finally {
                // Clear processing list
                processingListEl.value = '';
                isProcessing = false;
                document.getElementById('processingIndicator').innerHTML = '';
                saveQueuesToStorage();
                
                // Process next item immediately (small delay to prevent tight loop)
                console.log('[AUTO-PROCESSOR] Processing complete, checking for next item...');
                setTimeout(processNextLink, 500);
            }
        }
        
        // Move URL to finished list
        function moveToFinished(url) {
            const finishedListEl = document.getElementById('finishedList');
            const currentFinished = finishedListEl.value.trim();
            finishedListEl.value = currentFinished ? `${currentFinished}\n${url}` : url;
        }
        
        // Move URL to failed list
        function moveToFailed(url, error) {
            const failedListEl = document.getElementById('failedList');
            const currentFailed = failedListEl.value.trim();
            const entry = `${url} - Error: ${error}`;
            failedListEl.value = currentFailed ? `${currentFailed}\n${entry}` : entry;
        }
        
        function handleFileSelect(event) {
            const files = Array.from(event.target.files);
            selectedFiles = [...selectedFiles, ...files];
            updateFileList();
        }
        
        function updateFileList() {
            const fileList = document.getElementById('fileList');
            if (selectedFiles.length === 0) {
                fileList.innerHTML = '';
                return;
            }
            
            fileList.innerHTML = selectedFiles.map((file, index) => `
                <div class="file-item">
                    <span class="file-item-name" title="${file.name}">${file.name}</span>
                    <span class="file-remove" onclick="removeFile(${index})" title="Remove">√ó</span>
                </div>
            `).join('');
        }
        
        function removeFile(index) {
            selectedFiles.splice(index, 1);
            updateFileList();
            // Clear the file input
            document.getElementById('emailAttachment').value = '';
        }
        
        async function sendQuickEmail() {
            const emailText = document.getElementById('emailText').value.trim();
            const quickEmailBtn = document.getElementById('quickEmailBtn');
            
            if (!emailText) {
                showStatus('Please enter a message', 'error');
                return;
            }
            
            quickEmailBtn.disabled = true;
            quickEmailBtn.innerHTML = '<span class="loading"></span> Sending...';
            showStatus('Sending email...', 'info');
            
            try {
                const formData = new FormData();
                formData.append('message', emailText);
                
                // Add files to form data
                selectedFiles.forEach((file, index) => {
                    formData.append('attachments', file);
                });
                
                const response = await fetch('/send_quick_email', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showStatus('Email sent successfully!', 'success');
                    document.getElementById('emailText').value = '';
                    selectedFiles = [];
                    updateFileList();
                    document.getElementById('emailAttachment').value = '';
                } else {
                    showStatus(data.error || 'Failed to send email', 'error');
                }
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
            } finally {
                quickEmailBtn.disabled = false;
                quickEmailBtn.textContent = 'Send Email';
            }
        }
        
        async function sendQuickTelegram() {
            const emailText = document.getElementById('emailText').value.trim();
            const quickTelegramBtn = document.getElementById('quickTelegramBtn');
            
            if (!emailText) {
                showStatus('Please enter a message', 'error');
                return;
            }
            
            quickTelegramBtn.disabled = true;
            quickTelegramBtn.innerHTML = '<span class="loading"></span> Sending...';
            showStatus('Sending to Telegram...', 'info');
            
            try {
                const formData = new FormData();
                formData.append('message', emailText);
                
                // Add files to form data
                selectedFiles.forEach((file, index) => {
                    formData.append('attachments', file);
                });
                
                const response = await fetch('/send_quick_telegram', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showStatus('Telegram message sent successfully!', 'success');
                    document.getElementById('emailText').value = '';
                    selectedFiles = [];
                    updateFileList();
                    document.getElementById('emailAttachment').value = '';
                } else {
                    showStatus(data.error || 'Failed to send Telegram message', 'error');
                }
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
            } finally {
                quickTelegramBtn.disabled = false;
                quickTelegramBtn.textContent = '‚úàÔ∏è Telegram';
            }
        }
        
        async function generateAudio() {
            const text = document.getElementById('audioText').value.trim();
            const btn = document.getElementById('generateAudioBtn');
            const statusDiv = document.getElementById('audioStatus');
            const playerDiv = document.getElementById('audioPlayer');
            
            if (!text) {
                showAudioStatus('Please enter some text', 'error');
                return;
            }
            
            btn.disabled = true;
            btn.textContent = '‚è≥ Generating...';
            showAudioStatus('Processing text... This may take a moment for large text.', 'info');
            playerDiv.style.display = 'none';
            
            try {
                const response = await fetch('/text_to_audio', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ text: text })
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    showAudioStatus(`‚úÖ ${data.message}`, 'success');
                    
                    // Show audio player
                    const audioSource = document.getElementById('audioSource');
                    audioSource.src = `/kokoro_outputs/${data.audio_file}`;
                    document.querySelector('#audioPlayer audio').load();
                    playerDiv.style.display = 'block';
                } else {
                    showAudioStatus(`‚ùå ${data.error || 'Failed to generate audio'}`, 'error');
                }
            } catch (error) {
                showAudioStatus(`‚ùå Error: ${error.message}`, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'üéôÔ∏è Generate Audio';
            }
            
            function showAudioStatus(message, type) {
                statusDiv.textContent = message;
                statusDiv.style.display = 'block';
                statusDiv.style.background = type === 'error' ? '#ffebee' : 
                                             type === 'success' ? '#e8f5e9' : '#e3f2fd';
                statusDiv.style.color = type === 'error' ? '#c62828' : 
                                        type === 'success' ? '#2e7d32' : '#1565c0';
            }
        }
        
        function selectMode(mode) {
            if (isLoading) return;
            
            currentMode = mode;
            
            // Update UI - find the mode option by mode value
            document.querySelectorAll('.mode-option').forEach(option => {
                option.classList.remove('active');
            });
            
            // Add active class to the correct mode option
            const modeId = `mode${mode.charAt(0).toUpperCase() + mode.slice(1)}`;
            const selectedOption = document.getElementById(modeId).closest('.mode-option');
            if (selectedOption) {
                selectedOption.classList.add('active');
            }
            
            // Update placeholder text
            const urlInput = document.getElementById('urlInput');
            if (mode === 'news') {
                urlInput.placeholder = 'Enter news article URL (e.g., https://example.com/article)';
            } else if (mode === 'youtube') {
                urlInput.placeholder = 'Enter YouTube video URL (e.g., https://youtube.com/watch?v=...)';
            }
            
            // Check the radio button
            document.getElementById(modeId).checked = true;
        }
        
        function showStatus(message, type = 'info') {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.className = `status status-${type}`;
            statusDiv.innerHTML = message;
            statusDiv.style.display = 'block';
            
            // Only auto-hide success messages, not errors
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 5000);
            }
        }
        
        function createCopyButton(content, position) {
            const copyBtn = document.createElement('button');
            copyBtn.innerHTML = 'üìã Copy';
            copyBtn.title = 'Copy to clipboard';
            copyBtn.style.cssText = 'margin: 5px 0; padding: 6px 12px; background: #667eea; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.2s;';
            copyBtn.onmouseover = () => {
                copyBtn.style.background = '#5568d3';
                copyBtn.style.transform = 'translateY(-1px)';
            };
            copyBtn.onmouseout = () => {
                copyBtn.style.background = '#667eea';
                copyBtn.style.transform = 'translateY(0)';
            };
            copyBtn.onclick = () => {
                navigator.clipboard.writeText(content).then(() => {
                    copyBtn.innerHTML = '‚úì Copied';
                    copyBtn.style.background = '#4caf50';
                    setTimeout(() => {
                        copyBtn.innerHTML = 'üìã Copy';
                        copyBtn.style.background = '#667eea';
                    }, 2000);
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    copyBtn.innerHTML = '‚úó Failed';
                    copyBtn.style.background = '#f44336';
                    setTimeout(() => {
                        copyBtn.innerHTML = 'üìã Copy';
                        copyBtn.style.background = '#667eea';
                    }, 2000);
                });
            };
            return copyBtn;
        }

        function addMessage(content, isUser = false, audioFile = null, tokenUsage = null, timings = null) {
            const chatContainer = document.getElementById('chatContainer');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'message-user' : 'message-assistant'}`;
            
            const label = document.createElement('div');
            label.className = 'message-label';
            label.textContent = isUser ? 'You' : 'Assistant';
            
            messageDiv.appendChild(label);
            
            // Top copy button
            const topCopyBtn = createCopyButton(content, 'top');
            messageDiv.appendChild(topCopyBtn);
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.textContent = content;
            
            messageDiv.appendChild(contentDiv);
            
            // Bottom copy button
            const bottomCopyBtn = createCopyButton(content, 'bottom');
            messageDiv.appendChild(bottomCopyBtn);
            
            // Add timing info if available
            if (timings && !isUser) {
                const timingDiv = document.createElement('div');
                timingDiv.style.cssText = 'margin-top: 8px; padding: 8px 12px; background: #fff3e0; border-left: 3px solid #ff9800; font-size: 13px; color: #555; border-radius: 4px;';
                let timingText = `‚è±Ô∏è <strong>Timing:</strong> LLM: <strong>${timings.llm_time}s</strong>`;
                if (timings.audio_time) {
                    timingText += ` | Audio: <strong>${timings.audio_time}s</strong> | Total: <strong>${(timings.llm_time + timings.audio_time).toFixed(2)}s</strong>`;
                }
                timingDiv.innerHTML = timingText;
                messageDiv.appendChild(timingDiv);
            }
            
            // Add token usage info if available
            if (tokenUsage && !isUser) {
                const tokenDiv = document.createElement('div');
                tokenDiv.style.cssText = 'margin-top: 8px; padding: 8px 12px; background: #e8f4f8; border-left: 3px solid #667eea; font-size: 13px; color: #555; border-radius: 4px;';
                tokenDiv.innerHTML = `üìä <strong>Tokens:</strong> Prompt: <strong>${tokenUsage.prompt_tokens}</strong> | Completion: <strong>${tokenUsage.completion_tokens}</strong> | Total: <strong>${tokenUsage.total_tokens}</strong>`;
                messageDiv.appendChild(tokenDiv);
            }
            
            // Add audio player if audio file is provided
            if (audioFile && !isUser) {
                const audioContainer = document.createElement('div');
                audioContainer.style.marginTop = '10px';
                audioContainer.style.padding = '10px';
                audioContainer.style.background = '#f0f0f0';
                audioContainer.style.borderRadius = '8px';
                
                const audioElement = document.createElement('audio');
                audioElement.controls = true;
                audioElement.style.width = '100%';
                audioElement.src = `/audio/${audioFile}`;
                
                audioContainer.appendChild(audioElement);
                messageDiv.appendChild(audioContainer);
            }
            
            chatContainer.appendChild(messageDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }
        
        async function loadContent() {
            const urlInput = document.getElementById('urlInput');
            const url = urlInput.value.trim();
            
            if (!url) {
                showStatus('Please enter a valid URL', 'error');
                return;
            }
            
            if (isLoading) return;
            isLoading = true;
            
            const loadBtn = document.getElementById('loadBtn');
            loadBtn.disabled = true;
            loadBtn.innerHTML = '<span class="loading"></span>';
            
            const loadingMessage = currentMode === 'news' ? 'Loading and condensing article...' : 'Loading and condensing transcript...';
            showStatus(loadingMessage, 'info');
            
            try {
                const response = await fetch('/load_content', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        url,
                        mode: currentMode
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Store the URL for later use
                    currentUrl = url;
                    
                    // Display the condensed content as assistant message with audio
                    const contentType = currentMode === 'news' ? 'Article' : 'Transcript';
                    
                    // Create timing info if available
                    const timings = data.audio_time ? {
                        llm_time: 0,  // No LLM time in load_content
                        audio_time: data.audio_time
                    } : null;
                    
                    addMessage(`${contentType} Content (Condensed):\n\n${data.content}`, false, data.audio_file, null, timings);
                    
                    // Display word count with original vs condensed stats
                    if (data.word_count) {
                        const wordCountDiv = document.createElement('div');
                        wordCountDiv.style.cssText = 'margin: 10px 0; padding: 10px; background: #e8f4f8; border-left: 3px solid #667eea; font-size: 14px; color: #555; border-radius: 4px; text-align: center;';
                        
                        const compressionRatio = ((1 - data.word_count / data.original_word_count) * 100).toFixed(1);
                        wordCountDiv.innerHTML = `üìù Content condensed: <strong>${data.original_word_count.toLocaleString()}</strong> words ‚Üí <strong>${data.word_count.toLocaleString()}</strong> words <span style="color: #4caf50;">(${compressionRatio}% reduction)</span>`;
                        document.getElementById('chatContainer').appendChild(wordCountDiv);
                    }
                    
                    // Enable chat input immediately
                    document.getElementById('chatInput').disabled = false;
                    document.getElementById('sendBtn').disabled = false;
                    
                    // Show send email/telegram buttons if audio was generated
                    if (data.audio_file) {
                        showEmailButton(data.audio_file, data.content, url);
                    }
                    
                    const successMessage = currentMode === 'news' ? 'Article condensed! Ready for Q&A.' : 'Transcript condensed! Ready for Q&A.';
                    showStatus(successMessage, 'success');
                } else {
                    showStatus(data.error || 'Failed to load content', 'error');
                }
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
            } finally {
                isLoading = false;
                loadBtn.disabled = false;
                loadBtn.textContent = 'Load Content';
            }
        }
        
        function showEmailButton(audioFile, content, url) {
            const chatContainer = document.getElementById('chatContainer');
            const buttonContainer = document.createElement('div');
            buttonContainer.id = 'email-button-container';
            buttonContainer.style.cssText = 'text-align: center; padding: 15px; margin: 10px 0; display: flex; gap: 10px; justify-content: center;';
            
            // Email button
            const emailBtn = document.createElement('button');
            emailBtn.textContent = 'üìß Send to Email';
            emailBtn.className = 'btn btn-primary';
            emailBtn.style.cssText = 'padding: 12px 30px; font-size: 16px; cursor: pointer; background: #4caf50;';
            emailBtn.onmouseover = () => emailBtn.style.background = '#45a049';
            emailBtn.onmouseout = () => emailBtn.style.background = '#4caf50';
            emailBtn.onclick = () => sendEmail(audioFile, content, url);
            
            // Telegram button
            const telegramBtn = document.createElement('button');
            telegramBtn.textContent = '‚úàÔ∏è Send to Telegram';
            telegramBtn.className = 'btn btn-primary';
            telegramBtn.style.cssText = 'padding: 12px 30px; font-size: 16px; cursor: pointer; background: #0088cc;';
            telegramBtn.onmouseover = () => telegramBtn.style.background = '#006699';
            telegramBtn.onmouseout = () => telegramBtn.style.background = '#0088cc';
            telegramBtn.onclick = () => sendTelegram(audioFile, content, url);
            
            buttonContainer.appendChild(emailBtn);
            buttonContainer.appendChild(telegramBtn);
            chatContainer.appendChild(buttonContainer);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        async function sendEmail(audioFile, content) {
            const buttonContainer = document.getElementById('email-button-container');
            const emailBtn = buttonContainer?.querySelector('button');
            
            if (emailBtn) {
                emailBtn.disabled = true;
                emailBtn.innerHTML = '<span class="loading"></span> Sending...';
            }

            showStatus('Sending email...', 'info');
            
            try {
                const response = await fetch('/send_email', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        audio_file: audioFile,
                        content: content,
                        mode: currentMode
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showStatus('Email sent successfully!', 'success');
                    if (buttonContainer) {
                        buttonContainer.remove();
                    }
                } else {
                    showStatus(data.error || 'Failed to send email', 'error');
                    if (emailBtn) {
                        emailBtn.disabled = false;
                        emailBtn.textContent = 'üìß Send to Email';
                    }
                }
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
                if (emailBtn) {
                    emailBtn.disabled = false;
                    emailBtn.textContent = 'üìß Send to Email';
                }
            }
        }
        
        async function sendTelegram(audioFile, content, url) {
            const buttonContainer = document.getElementById('email-button-container');
            const telegramBtn = buttonContainer?.querySelectorAll('button')[1];
            
            if (telegramBtn) {
                telegramBtn.disabled = true;
                telegramBtn.innerHTML = '<span class="loading"></span> Sending...';
            }

            showStatus('Sending to Telegram...', 'info');
            
            try {
                const response = await fetch('/send_telegram', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        audio_file: audioFile,
                        content: content,
                        mode: currentMode,
                        url: url
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showStatus('Telegram message sent successfully!', 'success');
                    if (telegramBtn) {
                        telegramBtn.remove();
                    }
                } else {
                    showStatus(data.error || 'Failed to send Telegram message', 'error');
                    if (telegramBtn) {
                        telegramBtn.disabled = false;
                        telegramBtn.textContent = '‚úàÔ∏è Send to Telegram';
                    }
                }
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
                if (telegramBtn) {
                    telegramBtn.disabled = false;
                    telegramBtn.textContent = '‚úàÔ∏è Send to Telegram';
                }
            }
        }
        
        async function analyzeContent() {
            isLoading = true;
            showStatus(currentMode === 'news' ? 'Analyzing article...' : 'Summarizing transcript...', 'info');
            
            // Create placeholder message for streaming
            const chatContainer = document.getElementById('chatContainer');
            const placeholderDiv = document.createElement('div');
            placeholderDiv.className = 'message message-assistant';
            placeholderDiv.id = 'streaming-message';
            
            const label = document.createElement('div');
            label.className = 'message-label';
            label.textContent = 'Assistant';
            placeholderDiv.appendChild(label);
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.textContent = '';
            placeholderDiv.appendChild(contentDiv);
            
            chatContainer.appendChild(placeholderDiv);
            
            try {
                console.log('[STREAM] Starting analyze stream...');
                const response = await fetch('/streamChat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: 'analyze',
                        generate_audio: document.getElementById('audioCheckbox').checked
                    })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let accumulatedText = '';
                let chunkCount = 0;
                let streamBuffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

<!--                    const chunk = decoder.decode(value);-->
<!--                    const lines = chunk.split('\n');-->


                    streamBuffer += decoder.decode(value, { stream: true });
                    let lines = streamBuffer.split("\n\n");
                    streamBuffer = lines.pop();
                    console.log("lines")
                    console.log(lines)

                    for (const line of lines) {
                        if (line.startsWith('data:')) {
                            try {
                                const data = JSON.parse(line.slice(5));
                                console.log('[STREAM] Received data:', data);
                                
                                // Check for errors
                                if (data.error) {
                                    placeholderDiv.remove();
                                    if (buttonContainer) {
                                        buttonContainer.remove();
                                    }
                                    showStatus('Error: ' + data.error, 'error');
                                    break;
                                }
                                
                                // Handle streaming chunks (only has 'chunk' field)
                                if (data.chunk !== undefined) {
                                    console.log('[STREAM] Adding chunk, length:', data.chunk.length);
                                    chunkCount++;
                                    accumulatedText += data.chunk;
                                    contentDiv.textContent = accumulatedText;
                                    // Don't force scroll - let user explore previous messages
                                } 
                                // Handle streaming complete, show audio loader if needed
                                else if (data.streaming_done === true) {
                                    console.log('[STREAM] Streaming done, audio generation starting...');
                                    // Change placeholder to show audio loading
                                    contentDiv.textContent = accumulatedText;
                                    const audioLoader = document.createElement('div');
                                    audioLoader.style.cssText = 'margin-top: 10px; padding: 10px; background: #fff3e0; border-left: 3px solid #ff9800; font-size: 13px; color: #555; border-radius: 4px;';
                                    audioLoader.innerHTML = 'üéµ <span class="loading"></span> Generating audio...';
                                    placeholderDiv.appendChild(audioLoader);
                                }
                                // Handle final metadata message (has 'done' field)
                                else if (data.done === true) {
                                    console.log(`[STREAM] Done. Chunks: ${chunkCount}, Length: ${accumulatedText.length}`);
                                    // Remove placeholder and add final message with metadata
                                    placeholderDiv.remove();
                                    
                                    if (buttonContainer) {
                                        buttonContainer.remove();
                                    }
                                    
                                    const timings = {
                                        llm_time: data.llm_time || 0,
                                        audio_time: data.audio_time || null
                                    };
                                    
                                    addMessage(accumulatedText, false, data.audio_file, data.token_usage, timings);
                                    
                                    // Enable chat input after analysis
                                    document.getElementById('chatInput').disabled = false;
                                    document.getElementById('sendBtn').disabled = false;
                                    showStatus('Analysis complete! You can now ask questions.', 'success');
                                }
                            } catch (e) {
                                console.error('Error parsing SSE data:', e);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('[STREAM] Analyze error:', error);
                // Remove placeholder on error
                const placeholder = document.getElementById('streaming-message');
                if (placeholder) placeholder.remove();
                
                // Restore button on error
                if (analyzeBtn) {
                    analyzeBtn.disabled = false;
                    analyzeBtn.textContent = currentMode === 'news' ? 'üì∞ Analyze Article' : 'üé¨ Summarize Transcript';
                }
                showStatus('Error analyzing content: ' + error.message, 'error');
            } finally {
                isLoading = false;
            }
        }

        async function sendMessage() {
            const chatInput = document.getElementById('chatInput');
            const message = chatInput.value.trim();
            
            if (!message || isLoading) return;
            
            isLoading = true;
            const sendBtn = document.getElementById('sendBtn');
            sendBtn.disabled = true;
            sendBtn.innerHTML = '<span class="loading"></span>';
            
            addMessage(message, true);
            chatInput.value = '';
            
            const generateAudio = document.getElementById('audioCheckbox').checked;
            
            // Create placeholder message for streaming
            const chatContainer = document.getElementById('chatContainer');
            const placeholderDiv = document.createElement('div');
            placeholderDiv.className = 'message message-assistant';
            placeholderDiv.id = 'streaming-message';
            
            const label = document.createElement('div');
            label.className = 'message-label';
            label.textContent = 'Assistant';
            placeholderDiv.appendChild(label);
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.textContent = '';
            placeholderDiv.appendChild(contentDiv);
            
            chatContainer.appendChild(placeholderDiv);
            
            try {
                console.log('[STREAM] Starting message stream...');
                const response = await fetch('/streamChat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        message,
                        generate_audio: generateAudio
                    })
                });
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let accumulatedText = '';
                let chunkCount = 0;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data:')) {
                            try {
                                const data = JSON.parse(line.slice(5));
                                console.log('[STREAM] Received data:', data);
                                
                                // Check for errors
                                if (data.error) {
                                    placeholderDiv.remove();
                                    showStatus('Error: ' + data.error, 'error');
                                    break;
                                }
                                
                                // Handle streaming chunks (only has 'chunk' field)
                                if (data.chunk !== undefined) {
                                    console.log('[STREAM] Adding chunk, length:', data.chunk.length);
                                    chunkCount++;
                                    accumulatedText += data.chunk;
                                    contentDiv.textContent = accumulatedText;
                                    // Don't force scroll - let user explore previous messages
                                } 
                                // Handle streaming complete, show audio loader if needed
                                else if (data.streaming_done === true) {
                                    console.log('[STREAM] Streaming done, audio generation starting...');
                                    // Change placeholder to show audio loading
                                    contentDiv.textContent = accumulatedText;
                                    const audioLoader = document.createElement('div');
                                    audioLoader.style.cssText = 'margin-top: 10px; padding: 10px; background: #fff3e0; border-left: 3px solid #ff9800; font-size: 13px; color: #555; border-radius: 4px;';
                                    audioLoader.innerHTML = 'üéµ <span class="loading"></span> Generating audio...';
                                    placeholderDiv.appendChild(audioLoader);
                                }
                                // Handle final metadata message (has 'done' field)
                                else if (data.done === true) {
                                    console.log(`[STREAM] Message complete. Chunks: ${chunkCount}, Length: ${accumulatedText.length}`);
                                    // Remove placeholder and add final message with metadata
                                    placeholderDiv.remove();
                                    
                                    const timings = {
                                        llm_time: data.llm_time || 0,
                                        audio_time: data.audio_time || null
                                    };
                                    
                                    addMessage(accumulatedText, false, data.audio_file, data.token_usage, timings);
                                    
                                    if (data.audio_file) {
                                        showStatus('Response with audio ready!', 'success');
                                    }
                                }
                            } catch (e) {
                                console.error('Error parsing SSE data:', e);
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('[STREAM] Message error:', error);
                // Remove placeholder on error
                const placeholder = document.getElementById('streaming-message');
                if (placeholder) placeholder.remove();
                
                showStatus('Error: ' + error.message, 'error');
            } finally {
                isLoading = false;
                sendBtn.disabled = false;
                sendBtn.textContent = 'Send';
            }
        }
        
        async function clearConversation() {
            if (!confirm('Are you sure you want to clear the conversation?')) {
                return;
            }
            
            try {
                const response = await fetch('/clear_conversation', {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (data.success) {
                    document.getElementById('chatContainer').innerHTML = '';
                    document.getElementById('chatInput').disabled = true;
                    document.getElementById('sendBtn').disabled = true;
                    document.getElementById('urlInput').value = '';
                    showStatus('Conversation cleared', 'success');
                }
            } catch (error) {
                showStatus('Error: ' + error.message, 'error');
            }
        }
        
        function handleKeyPress(event) {
            if (event.key === 'Enter' && !isLoading) {
                sendMessage();
            }
        }
    </script>
</body>
</html>
